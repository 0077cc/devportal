#!groovy

// Load shared pipeline library
@Library('velox') _
def cronInterval = isPromotableBranch(env.BRANCH_NAME) || env.BRANCH_NAME == "develop-2018.4.1" ? "20 */3 * * 1-5" : ""

properties([
        buildDiscarder(logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '7', numToKeepStr: '')),
        disableResume(),
        parameters([
                string(name: 'GIT_COMMIT', defaultValue: scm.branches.get(0).getName(), description: 'The commit/ref to build an image from'),
                booleanParam(name: 'RUN_TESTS', defaultValue: true, description: 'Run Behat Tests'),
                booleanParam(name: 'FORCE_RUN', defaultValue: false, description: 'Force run the entire build')
        ]),
        pipelineTriggers([cron(cronInterval)])
])

def pipelineOpts = [
        slackChannel: '',
        labels      : 'portal-taas',
        nodeVersion : 10.15,
]

veloxPipeline(pipelineOpts) { p ->
  // Get relevant info for slack notifications
  env.GIT_COMMIT_URL = "https://github.ibm.com/apimesh/devportal-apim-profile/commit/${env.GIT_COMMIT}"
  env.GIT_COMMIT_MSG = sh (script: 'git log --format=%B -n 1 $GIT_COMMIT | head -n 1', returnStdout: true).trim()
  env.UP_BUILD_URL = getBuildCauses().first().BUILD_URL ?: ''
  env.UP_BUILD_NAME = getBuildCauses().first().BUILD_NAME ?: 'build'
  def releaseName = env.CHANGE_ID ? env.CHANGE_BRANCH : env.BRANCH_NAME
  def LOCAL_BRANCH_NAME = env.BRANCH_NAME
  def buildResult

  p.PR {
    LOCAL_BRANCH_NAME = releaseName
    buildResult = portal.getLatestBranchBuildResult(LOCAL_BRANCH_NAME)
  }

  p.promotableBranch {
    def buildInfo = Artifactory.newBuildInfo()
    // set the primary build identifiers
    buildInfo.setName "portal-apim-profile-${releaseName}"
    buildInfo.setNumber currentBuild.id
    // For easier referencing by other Jenkins builds/jobs
    env.ARTIFACTS_BUILD = "${buildInfo.name}/${buildInfo.number}"
  }

  env.BUILD_TIMESTAMP = sh(script: 'date +%Y%m%d-%H%M', returnStdout: true).trim()
  def DOCKER_REGISTRY = 'apic-dev-docker-local.artifactory.swg-devops.com'

  def MODULES_CHANGED = false
  def MODULES_YAML_FILE = 'devportal-modules.yaml'
  def FORCE_RUN = params.FORCE_RUN

  // handle when a git push is detected
  if (currentBuild.rawBuild.getCauses().toString().contains('BranchEventCause')){
    if (env.GIT_COMMIT_MSG.contains('[ci-skip')) {
      println 'Git push with [ci-skip] detected. Exiting immediately.'
      currentBuild.result = 'SUCCESS'
      return
    } else {
      println 'Git push detected. We will run this build regardless of a module change.'
      FORCE_RUN = true
    }
  }

  p.promotableBranch {
    stage('Check for Devportal Version Change') {
      def localPath = "${HOME}/go/src/github.ibm.com/apimesh/devportal-apim-profile"
      def modulesYaml = readYaml file: MODULES_YAML_FILE
      MODULE_BRANCH = 'master'
      if (LOCAL_BRANCH_NAME == '2018.4.1' || LOCAL_BRANCH_NAME == 'cd') {
        MODULE_BRANCH = '2018.4.1'
      }

      portal.cloneAllModuleRepos(MODULE_BRANCH)
      def updatedModulesYaml = portal.updateYamlWithNewModuleVersions(localPath, modulesYaml)

      if (updatedModulesYaml != null) { 
        MODULES_CHANGED = true
        println "Saving new ${MODULES_YAML_FILE} file. This will be pushed to the repo if we're on a promotable branch"
        // the file must not exist, otherwise writeYaml will fail
        sh "rm -f ${MODULES_YAML_FILE}"
        writeYaml file: MODULES_YAML_FILE, data: modulesYaml
      }
    }
  }

  p.common {
    // end build immediately if this is a PR build and the branch build completed with SUCCESS or FAILIURE
    if (buildResult == 'SUCCESS' || buildResult == 'FAILURE') {
      currentBuild.result = buildResult
      return
    }

    try {
      ansiColor('xterm') {
        npmutils = library('bmxNative').jenkinsLibs.Node.new()
        npmutils.writeDotNpmrc()
        if (MODULES_CHANGED == true || FORCE_RUN == true) {
          stage('Check out portal-common') {
            MODULE_BRANCH = 'master'
            if (env.BRANCH_NAME == '2018.4.1' || env.BRANCH_NAME == 'cd') {
              MODULE_BRANCH = '2018.4.1'
            }
            portal.cloneGitRepoOrMaster('portal-common', env.BRANCH_NAME, 'apimesh', null, true)
          }

          stage('Build') {
            portal.writeAuthJsonFile();
            sh './build.sh'
          }

          stage('Pull portal-site-template Image') {
            portal.pullSiteTemplateImage(env.BRANCH_NAME, "master")
          }

          stage('Build Template') {
            sh './build_site_template.sh'
          }

          stage('Test') {
            if ((MODULES_CHANGED == true || FORCE_RUN == true) && params.RUN_TESTS == true) {
              try {
                sh './run_tests_in_template.sh'
              } finally {
                archiveArtifacts artifacts: 'tmp/behat/**/*', allowEmptyArchive: true
                archiveArtifacts artifacts: 'tmp/watchdog/*', allowEmptyArchive: true
              }
            }
          }
        }
      }
    } catch (Exception err) {
        if (isPromotableBranch(env.BRANCH_NAME) && e.class.toString() != "class hudson.AbortException" && currentBuild.result != 'ABORTED') {
          portal.sendSlackNotification(e, 'danger', REPO_NAME, 'apimesh')
        }
        throw err;
    }

  }

  p.promotableBranch {
    if (MODULES_CHANGED == true) {
      // we need to change from 'detached HEAD' to env.BRANCH_NAME before we can push
      stage('bump version') {
        sh """
          git checkout ${env.BRANCH_NAME}
          git add ${MODULES_YAML_FILE} ChangeLog.yml
          git commit -m 'bump module versions [ci-skip]'
          git fetch origin ${env.BRANCH_NAME}
          git rebase -X ours || true
          git push --set-upstream origin ${env.BRANCH_NAME}
        """
      }
    }

    if (MODULES_CHANGED == true || FORCE_RUN == true) {
      stage('Upload') {
        sh 'git rev-parse HEAD > apim-profile-git-commit.sha1'
        sh 'cd build; tar cfz platform-and-site-template-8.x-${BUILD_TIMESTAMP}.tgz *.tgz ../ChangeLog.yml ../apim-profile-git-commit.sha1'
        def artifactZip = findFiles(glob: 'build/platform-and-site-template-8.x-*.tgz')[0]
        def artifactPath = "apic-dev-docker-local/portal/apim-profile/${env.BRANCH_NAME}/${env.BUILD_NUMBER}/${artifactZip.name}"
        portal.uploadArtifactToArtifactory("./${artifactZip}", artifactPath)

        def fullArtifactUrl = "https://na.artifactory.swg-devops.com/artifactory/" + artifactPath
        currentBuild.description = "<a href=${fullArtifactUrl}>${env.BUILD_NUMBER}/${artifactZip.name}</a>"
      }

      stage('WWW Image Build') {
        build(job: "velox-portal/portal-www/${env.BRANCH_NAME}", propagate: true, wait: false)
      }
    }
  }
}
